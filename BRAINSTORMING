###################################################################################################################
####################### PARAMETER ORIGIN  #########################################################################
###################################################################################################################

About history (after brainstorming, it is not really an history, it is value origin)
    WHY?
        PBLM 1 how to know if is it necessary to recreate stored config or not ? SOLVED
            for not transient parameter, we have to know if the final value is different of the original value

            SOLUTION
                generate a hash of the parameter file on loading and compare it with a new hash at the saving process
                    if hash is equal and no difference in parameter AND there is no new candidate to be saved, don't save at exit
                    also keep the filePath, if a different parameter file is loaded OR the file destination is different, save at exit

                    count the number of parameter loaded from file, if there is less or more at the saving time, recreate the parameter file
                        if the number is equal from the loading, don't save

                add a single couple of data to parameter about current value origin OR properties origin, here are the possible values: (NEW FIELD: origin)
                    System         + None 
                    File           + filePath
                    Loader         + addonName
                    Procedure      + None

                ABSOLUTLY SAVE IN FOLLOWING CASES:
                    Origin=Procedure
                    Origin=File AND path is different of the destination file
                
                CANDIDATE FOR SAVING BUT DO NOT TRIGGER IT IN FOLLOWING CASES:
                    Origin=File AND path is the same of the destination file And exactly the same count of parameter loaded
                    
                DON'T SAVE IN FOLLOWING CASES:
                    Origin=System
                    Origin=Loader

                add a boolean "force" on removeParameter in container
                    if true, remove the parameter in anyway
                    if false AND there is at least one loader register, raise

        PBLM 2 loader add/create parameter on loading and should remove then on unloading SOLVED
            except if another element update the value (custom update, other addon, ...)

            not exactly, the problem is if two or several different addons want to create a parameter with the same key
                the first loaded addon will create the parameter
                the others parameter won't create again the parameter
                if the first loaded addon is unloaded, it will remove the parameter, the other addons won't


            SOLUTION
                record a list of addon that need this parameter (NEW FIELD)
                and only removed the parameter on the last addon unloading (or program exit) AND if the current value origin is Addon
                    an addon record itself in the list, or remove itself from the list through the loader system

                on statup ONLY, if a value exist from file, it can't be overwritte by an addon
                    after the startup, if an addon is loaded, it could overwritte the value
                        need to find a way to say to the loader that this is the startup procedure
                        ideally forbide to execute startup a second time

        PRBLM 3: if a loader just overwrites the full parameter, not only set a new value
                 setParameter from container in place of setValue from parameter
            
            it will overwrite the information stored into the parameter
                the information about loader, a simple list

            SOLUTION 1: if parameter already exists, manage it into the container and merge information from old one with the new one XXX
            SOLUTION 2: store these information outside of the parameter, so you will never lose them
            
            the SOLUTION 1 is better and simpler, because just need to store a list
                So when a parameter want to overwrite an existing one, just merge loader list
            
        PRBLM 4: how to know where the update come from ?
            for "System" and "Loader", it is easy because the parameter setting occurs in a well defined place.
            for "Procedure", it has to be the default origin, so no need to create specific mechanism
            for "File", it is the real problem, because the process loading occured into a process that occur into a file procedure
                we have no information to give to the parameterManager about the file origin
                
            SOLUTION 1: add an argument on command "set parameter" about origin
                +++ simple do install
                --- show an internal mechanism to the user
                --- a user could update origin in parameter file and break the logics of this stuff
                
            SOLUTION 2: create a local var to indicate the origin of the next parameter
            SOLUTION 2b: create an hidden command to indicate to the parameter manager that every following parameter will come from file
                And create another hidden command to indicate the loading is finished
                
                Yeah but what does occur if a crash happend during parameter loading ? there is a risk to never reset parameter origin
                    not really, a file loading run with a granularity of None, so the call will never stop to execute until the end of the file
                    
                these command call could be added by the parameter process that create the alias object at the begging and end of this alias
                
            SOLUTION 3: create a method in parameterManager to setOriginOfParameter XXX
                this information will be used to set the origin of every parameter for the current thread only
                    so at the end of the thread life, this information disappear
                    
                set it in the process to load the file
                use it everywhere, for Loader, System, Process, File
                Default Value => Process
                
                create a hidden method getOriginParameter that will be used by parameterManager
                    this method also need to be called in parameter during setValue or setProperties or related function

        PRBLM 5: if a loader just update a properties, the object origin will be flagged "from loader"
            But maybe the value or another properties of this object was set from a procedure and has to be saved on file...

            SOLUTION 1: each properties/value has an origin, not only the full object
                --- aouch, increase memory usage, should be possible to find a smarter solution

            SOLUTION 2: 
                 reduce origin seed: system/loader are the same kind, keep file and procedure
                 if a parameter is flagged system/loader, just store the flag
                 if a parameter is flagged procedure/file, keep a list of flagged properties name
                    until at least one item is flaggeg procedure/file, the whole parameters is flagged like that

                procedure > file > loader

                    even if everything is flagged file except one thing that is flagged procedure
                    the parameter remains flagged procedure

                if every properties are flagged procedure or file, keep an empty list of properties name

                What about two files origin ?

                --- could still use a lot of memory even if it is in a smarter way

            SOLUTION 3: keep a variable with the origin of the creator of the param
                at exit, the creator of the parameter will check if the parameter created has changed, if yes, the parameter is flagged as "TO SAVE"

                have to unload parameter in the opposite order as the loading

                PRBLM 1: if the loader responsible for a parameter is already unloaded before the unloading process ?
                PRBLM 2: what about files? the original copy of the parameter is stored on disk, maybe a change occured on the file
                         between loading and unloading

            SOLUTION 4: keep the creator origin and the hash of the parameter at its creation XXX
                if system/loader origin and no diff of the hash, don't save
                if file origin and no diff of the hash, candidate to be saved
                if process and no diff of the hash, to absolutely save

                if diff on the hash, absolutely save

                +++ no extra data in memory
                +++ simple process at exit, just recompute the hash and compare
                +++ easy to implement

                PRBLM 1: if the object is updated BUT because of the loading of an addon
                    the parameter does not need to be saved but the hash will be different

                    SOLUTION 1 : if a loader recreate a parameter, overwrite the origin and the hash in parameter

        PRBLM 6: add/remove some of the values SOLVED
            it's not a complete "setValue"
            
            SOLUTION 1: keep a start index, and a end index of value stored by each loader
                because it is not allowed to add value at a specific index in environmentParameter, you can only add/remove value
                So we don't need more information
                could be possible to set: -a single value (range length = 1)
                                          -a range value (range length > 1)
                                          -all value (range length = max)
                                          -No value (range length = 0)
                                          
                even if all the value added by a loader are removed, the loader is still dependant of the parameter
                
                QUESTION: with such system, we will precisely know at the save which value come from the loader
                    Is loader origin/hash still needed ? because we will be able to identify precisely every value in the parameter coming from a loader
                    startingHash is still needed to know if file is different from file, still need to know file name
                    if does not come from file, set hash to None
                    FALSE => origin not really needed anymore for loader or procedure
                    
                    FALSE, hash is still needed for settings when parameter come from file or loader
                        if an update is processed in these type of parameter, we need to know it
                        but starting hash can be None in case of creation in procedure by user
                    
                PRBLM 1: if a user removed a value added by a loader, it becomes a custom parameter or not ?
                    because on the next reboot, the removed value will come back
                    but if we store loader value, then reload them, they will become value from file and not from loader...
                    
                    SOLUTION 1 : keep a list of bannished value for the loader
                        this list will be loaded on parameter loading
                        and after that if a loader try to load this value, an error will occur
                        But if the user set this value, value will go out of the banished list
                
                PRBLM 2: And if add it after the removal ? does it come back to the loader origin ? 
                    definitely not
                    
                    SOLUTION 1 : related with the SOLUTION 1 of the previous prlbm
                        the value will go out of the banished list
                        but will have a USER value, NOPE

                        PRBLM if a loader value if manually removed, then added
                              we have to store the value on file, restart the application, remove the value, then restart the application again
                              And only at this moment, the loader will be able again to load the value
                              
                        A value retired from the banished list, should not be saved on file

                PRBLM 3: parameter list with no unicity system, so two loader (or the same loader) could add several time the same value
                    if one occurence of this value is removed and put in the banished list
                    on next reboot, none of the occurence of this value will be allowed...

                    SOLUTION 1: keep the name of loader associated with the banished value AND a counter
                        so if a loader add several time the same value, we can count how many time the value should be banished
                        And if another loader try to add an occurence of this value, it will be allowed

                        need to update banished list
                        
        PRBLM 7: SOLVED
            a parameter is created by one or several loader
            an user update one of the settings (e.g readOnly) BUT don't add any value in the parameter
            then exit the software, the parameter will be marked as "to be saved" but does not hold any value
            
            if the software restart, the parameter will be saved, and even if the user reset the status of this parameter to the origin one, it will stay forever empty in the saving process
                except if the user remove the parameter
            
            SOLUTION 1: only keep loader/process as value origin and store them in parameters file (origin could become a boolean)
                no need of origin and orign arg
                only need one field: loaderOrigin, if it is set to None, the origin is process, otherelse, field will store the loader origin
            
                PRBLM 1: it implies that a command to set origin will be available to user...
                    SOLUTION 1: create hidden commands "parameter origin set", "parameter origin get", "parameter origin reset"
                        will only apply to the current thread
                        default origin: process
                
                PRBLM 2: lose of the "file origin" needed to compute the list of candidate to be saved
                    SOLUTION 1: add a field in globalSettings "fileOrigin" and store the filePath hash into
                        If the field is set to None, the parameter does not come from a file

********PRBLM 8: start to become overkill...
            should find a way to easy manage that. if it is not easy to get it, prblm of design or goals

            what we want:
                -do not save loader value (system included) if no value/settings modified
                -do not regenerate parameters files if not needed
                -get the params state as closed as possible as the params state at the end of previous exit
                    if the order and the count of the loader does not change, the params state must be exactly the same
                -add/remove value in a existing parameter

            goals:
                -loader set/unset value on loading
                -loader add/remove parameter on unloading
                -a user set/unset at any time
                -a user add/remove parameter at any time

            choice to do
                user can update loader parameters ?                                   : yes
                    the real question is the following one
                update on loaders parameters are stored like user parameters update ? : yes
                    or restored on every boot
                    
            idea:
                each addon has a config file for each updated profile (so if no update in the profile, no existing file)
                    this file will hold the removing value and the updated settings, so it will be load after addon profile
                        if no modification, no file (so we work as a "only update are saved" mode)
                    could be group into a single file once the jump/loop will exist
                    create a system that avoid to recreate addon config file if not needed
                    solve the problem of load value/settings for unexistant/unused parameter
                    the settings of the parameters are stored in every addons files using this parameter
                        be carefull with that, if settings has changed but not saved in every loaders because some of them weren't loaded
                    
                if a user add value in a parameter created by a loader
                    the value is stored in main parameter file (?)
                    the settings of the parameters are stored in every addons files using this parameter, including the main config file (?)
                
                system origin is managed like an unremoving loader
                    could have profile, and so different config file
                    new parameter is created into this loader, kind of orphanage
                
                a parameter has always a starting point loader (in worst case: system), value can be added/removed
                    so if you add a value, it will be stored in the config file of this starting point
                    
                but what about removal then adding ? how to make the difference between a new value and a removal undo ????
                    SOLUTION 1: no value tracking in parameter, unload each parameter at exit, create a default system loader
                        by loading inorder (from last loaded to first loaded), unload value one after the other
                            if a value is missing, mark it as removed in the config file
                            
                        if remaining value after unloaded every loaders, save the value in the original loaders
                        
                        --- need to unload every addons before to exit AND save file there if needed
                        
                        remove banish/unbanish list, keep a loader list (to know if the current loader is the last one)
                        no more need origin field, the first loader in list is the origin
                        
                        because every value will be unloaded, no need to hash on the value, only on settings
                        
                        need to include parameter/procedure loading/saving into loader mechanism, not in parameter anymore
                        and register addon unload at exit
                        parameter command group will disappear
                        
                        PRBLM 1: if we want to unload a addon that is the origin of several parameter AND these parameter are dependancies for other loaders (?)
                            remove value from parameter, if missing value in parameter save them
                            if loader still exist in the dependancies list, the next loader become the origin
                            
                            but extra value loaded from an addon config should stay in the same config file
                                so value loaded from file should appear in list valueToUnload

                        PRBLM 1b: what if unload a random addon ?
                            risk to grab some value from other loaders...
                                
                        PRBLM 2: what if no more value in list and still dependant loader
                            if env, no problem, if context prblm always need a value
                            
                    SOLUTION 2: okay okay, we need to know which value comes from which loader
                        and also which value is missing and which value is extra
                        
                        In addon, for each parameter:
                            list of "value to add"        (compute on registering)  (value to load)
                            list of "value to remove"     (compute on loading)      (loaded value to remove on unload)
                            
                            list of "extra value"         (come from addon config file)
                            list of "removed value"       (come from addon config file)
                            
                            "value to add", "extra value" and "removed value" should be in the same data structure behind the same key
                            
                        In memmory, for each parameter (to be implemented)
                            for each addon, "list of value" (only first index and size)
                            a "list of new value" (value added by user)
                        
                        Axioms
                            In addon, if no registering change, "value to add" will always be the same list
                            In addon, "list of value to remove" can change depending of the value loaded or not, extra value, removed value
                            intersection between "extra value" and "removed value" is always empty
                            in Parameter memmory, "list of value" can not be increase, it can decrease or stay the same
                        
                        Case study for a single parameter on addon load, compute a part of "list of value" and "value to remove"
                            if parameter exist
                                take the list "value to add"
                                substract the "removed value"
                                add the "extra value"
                                then add the value in the "list of value" of the parameter
                                and add the value in "value to remove"
                        
                        Case study for a single parameter on addon unload
                            extract "list of value" from parameter in memory, compare with the list of "value to remove"
                            If equal size
                                remove the loader from dependancies and remove the value from the parameter
                            else
                                look after missing value in the "list of new value"
                                if still missing value
                                    remove them from "extra value" if possible
                                    
                                    if still missing value
                                        add them in "removed value"
                            
                            if loader is the last one in the parameter dependancies list
                                if "list of new value" is not empty
                                    remove them from "removed value"
                                    
                                    if "list of new value" is still not empty
                                        add them in "extra value"

                                remove the parameter
                                
                        PRBLM 1: if a value is marked as removed in the addon But, on next reboot the parameter does not exist SOLVED
                            so the addon can't add its list of value on the parameter
                            And can't removed any value
                            And so at the save, value to removed will be lost...
                            
                            a registered value does not disappear if the parameter does not exist, store remove/extra value in the same data structure as registerd
                            
                        PRBLN 1b: Same problem with extra value than with removed value, if the parameter does not exist on next reboot SOLVED see previous
                            the information will be loose...
                            
                        PRBLM 2: if an extra value is stored in an addon config file, this value has to be in the "value to add" of the addon ? SOLVED
                            nope, extra value has to be identified in front of registered value 
                        
                        PRLBM 3: what to do if a parameter key exists in the addon config file but is not registered anymore in the addon ? SOLVED
                            remove the value from addon config file
                            
                        PRBLM 4: if an addon completly overwrite the parameter ? (setParameter) loose of every previous value SOLVED
                            an addon has the possibility to re create a parameter if it already exist, if it happens, previous value are removed
                            so at the other addons unloading, every value will be marked as "removed" but it is just overwrittin
                            
                            with value tracking, we can't just overwritte a parameter, we need to manage that
                            
                            SOLUTION 1.1: remove overwritting choice, it is out of the current design XXX
                                what about conflict ?
                                    if a parameter already exists with different type => error on the loader currently loaded
                                    if a parameter already exists with the same type => do no create 
                                    if no parameter exist, create it with provided settings
                                
                                lose power of expression...
                                yeah but the current design talk about sharing a parameter, no unique owner
                                
                            SOLUTION 1.2: remove setParameter in loader, only keep addValue
                                how to create parameter and set type ? 
                                    provide a type to create the parameter if it doesn't exist
                                    type could be None, so use default type
                            
                            SOLUTION 2.1: when overwritting, set a flag to the past loader to indicate that is not a remove
                            SOLUTION 2.2: when overwritting, keep loader as dependant but update their "value to remove" list by removing everything
                                what about new value ?
                                and what to do if overwritter is unloaded? restore old type and value ? 
                                
                                pretty ugly and overkill as solution
                            
                            SOLUTION 3: merge value if parameter type is the same
                                what to do if type is not the same ?
                                    => error ?
                                    => remove previous one ?
                                
                            SOLUTION 4: forbide overriden and create a system to maintain unicity name in anycase
                                for example if two loader want to create the same parameter name, but with different purpose
                                manage to have two separate name with transparency
                                
                                and create a boolean to explictly decide if we use unicity or reusability
                                    in the first case, a new parameter will be created in every loader using the same name
                                    in the second case, only one parameter will be create without overriding allowing but if type mismatch, an error will occur
                                
                                overkill... and will add so complexity in the parameter use
                                
                            SOLUTION 5: if an override occure, in overriden addon, remove extra value, and put every value in to be removed
                                prblm: if a reboot occured and the overrider addon is not loaded, no more value will be loaded from other addon
                        
                        PRBLM 5: loose the system of single file SOLVED
                        
                            SOLUTION 1 : become a system based on directory XXX
                                provide a directory to the application, not a config file
                            
                        PRBLM 6: distribution of settings change SOLVED
                            need a way to centralize settings but distribute values...
                            
                            SOLUTION 1: propagate them into every related addons
                                yeah but what about not loaded addons that have a dependancy to this parameter
                                they won't be updated, not a good solution
                                
                                last loaded addon will apply its settings
                                
                            SOLUTION 2: create a new files "politics" than will apply every change on the parameters setting
                                --- add an extra file, not related to any addon
                                
                            SOLUTION 3: set a version number to the settings, always apply the last one
                            
                            SOLUTION 4: put settings only into "system" addon config file + fantom parameter XXX
                                a fantom parameter == Global + no loader registered
                            
                                a fantom parameter is created with saved settings AND is not available until an addon registers to it
                                need a command to register the system addon to a fantom parameter
                                
                                on parameter listing, show the list of removed value (at the addon)
                                    only the static value coming from loader registering
                                
                                on listing, give the possibility to display fantom parameter (to eventually remove them)
                                    and also print removed value from addon
                        
                        PRBLM 7: how to know when to save ? SOLVED (more or less)
                            four cases
                            compare "removed value" and "extra value" from the beginning to the end of the execution
                            if both empty at the starting
                                if still empty at the end then do not save
                                else need to be saved
                            else #was previously stored
                                if the content had change then saved
                                else: candidate to be saved (if only candidate to be saved and file is still the same, do not save)
                                
                            yeah but what about the settings ? (see prblm 6)  
                            
                        PRBLM 8: this solution protect addons value from each others, so a loader can not steal any value to another loader
                            BUT does not manage value insertion for a specific addons, could cause logical choice but not understandable by a user...
                            
                            extra value are stored in system, is it a good idea ?
                            
                            but how to know if a value is a system one or a undo remove on loader ?
                            
                            And what about global not transient parameter created in the execution of an addon command ?
                                these parameters should have a dependancy to the creator loader
                                And so, should be saved in loader (parameter creation + value set)
                            
                            SOLUTION 1
                                on command "parameter set", "parameter add value", "parameter remove value",... add an argument "origin"
                                    This argument has to be an existing AND loaded loader name
                                    If leave empty, origin is system
                                
                                parameter created into loader command has loader origin and became extra parameter
                                store extra value and parameter for each addon in corresponding loader file
                            
            question:
                -a user can be able to remove/update a loader parameter ?
                    -if yes, the removed/updated loader/settings value has to be memorized ? 
                        if yes, need to:
                            *memorise the deleted value for each loader
                                but what to do with these value if the parameter is not created again on next boot ? 
                                
                                way to save :
                                    -everything has to be saved, and if parameter exist, loader does not do anything (except if overriding)
                                    -only modification (not default settings, new/removed value) are saved and loaders addapt themselves on loading
                                    -
                                    
                            *have a way to undo the remove/update (see next major question)
                            
                        if no, a reloading of the loader will restore the value
                    -if no, these parameter will act as "constant", readonly, transient, global, not removable, origin loader
                        can be updated in memory but will always be deleted at the loader reloading, not possible to switch transient boolean
                        only store index for context
                    
                -a user can be able to add a loader value ? (for exemple, to undo loader value removing ?)
                    -if yes, how to make distinction between user value and context value ?
                        if a user add a removed value, the value go back to the loader
                        if a user add a inexistant value, the value is marked as "from user"
                        
                    -if no, value/settings regenerating on loader reloading
                        other ways to regenerate values ?

###################################################################################################################
####################### PRINTING ##################################################################################
###################################################################################################################
    LIMIT
        python2 clearly limits the power of the printing, it is another problem in python3
            no possibility to override the output because of readline low level library
            
        possibility
            -keep a system with know limit and issues
            
            -try to print the information in another way
                -splitted shell
                -two opened shell
                - ?


    IDEA
        -faire un gestionnaire d'event
            on enregistre des events dans une liste
            tant qu'il n'y a pas de flush on affiche rien
            
            plusieurs thread peuvent pusher des events dedans
                quand afficher ?
                    -au premier flush 
                        -risque parfois d'avoir des affichages bizares
                            car on va afficher en partie les events d'un autre thread
                            
                    -au dernier flush
                        -risque de ne jamais avoir l'affichage
                        -sauf si on met un timeout
            
            -et il suffira de bloquer l'autocompl pdt l'affichage
            -ne r√©soud pas la redirection de l'output...

    printing control
        main thread (always only one)
            readline OR main routine (shell)
                never both
        
        secondary threadS (could be several of it)
            event routine
            event not related to routine (e.g. new card thread)
                should trigger a routine event

    What can output something ?
        print
            can create a custom function and use a lock
        autocompletion
            no control on print
                because print occurs inside of the readline library
            
            can replace completion printing method and use a lock inside
                
        printing the input in shell
            no control on print
                because print occur in the readline(?) or bash(?)

    what will be great to have
        set a lock on the output
        no more stuff to use in the user space
        
    What does not work
        replace print function
            not doable for the whole application
        encapsulate stdout
            broke autocompletion
        
    What could work
        use custom print function in

###################################################################################################################
####################### NEW LOADER MODEL ##########################################################################
###################################################################################################################

MODEL 1 (STRONG_ISOLATION):
    each loader has its own tuple of :
        context variables
        environment variables
        procedures
        key variables

    other loader can NOT update/read/access this tuple


MODEL 2 (MIDDLE_ISOLATION(procedures)): (inherit properties from model 1)

    each addon/profile own a file that contains update from the default state

    Create event where any addon can register procedure        
            PRBLM 1: how to manage event creation/deletion ?

                SOLUTION 1: (EXPLICIT) event are created at addon load, an addon will say which event it will trigger
                    prblm: if an addon want to register a procedure into an event and no addon need to use it
                        the event won't exist

                SOLUTION 2: (EXPLICIT) event are created at addon load, an addon will say where it will register a procedure
                    prblm: if an addon try to trigger an event with no procedure inside, this event won't exist

                SOLUTION 3: (IMPLICIT) procedure create event at registeration and delete it when an event is empty  XXX
                    prblm: if an addon try to trigger an event with no procedure inside, this event won't exist
                        solution: allow to trigger unexisting event


MODEL 3 (MIDDLE_ISOLATION(procedures, variables)) (inherit properties from model 2) XXX

    Create hierachy in addon, a child addon can read parent variables
    each addon is by default a child of addon System
    a child can change index value in parent context
    a parent could be aware of its children, but without an update right on the var

    QUESTION 1: multiple or single inheritance ?
        CHOICE 1: single XXX
            easiest model, but is it not too limitative ?

        CHOICE 2: multiple
            a child addon can not be loaded without its parent, if no conditionnal dependancy, load parent

            PRBLM 1: what if several parent hold same variable name ?
                could have ambiguous situation, need a system to identify the target parent
                not really cool to need a desambiguos system :/

            PRBLM 2: what if conditionnal dependancy ? (need A or need B)
                give a type to addon and allow to have a dependancy to a type of addon

    QUESTION 2: what can contains a procedure? only command call from parent and from current ?
        a procedure created by an addon can only be updated by this current addon or by the user

        CHOICE 1: procedure can only contain command from current of from parent
            +++ we are sure the procedure will only contains existing commands
            --- reduce rasticaly the power of the procedure

        CHOICE 2: procedure can contains command from any addon
            +++ can create any kind of procedure
            --- some of the used command can unexist

        CHOICE 3: addon has its dependancy system and procedure has its own multiple dependancy system XXX
            +++ can create any kind of procedure
            +++ no problem of dependancy at execution

    QUESTION 3: what can update a procedure of an addon ?
        CHOICE 1: only process from the origin addon and the user

        CHOICE 2: any process


    UPDATE TO DO:
        -procedure do not need to manage several subprocedure per addon
        -create a special type of transient procedure that can be updated by any addon, this type of procedure is "event"
            -in this type of procedure, need to be able to identify command origin for addon unload
            -no jump statement allowed in these procedure
        -in variable system, just managed extra value and removed value.  update can only come from addon or user
        -


MODEL 4 (WEAK_ISOLATION(procedures, variables)) (inherit properties from model 3)

    any child can update/access to the parent procedure/variable

    PRBLM 1: how to manage update/deletion/concurrent access/duplicate/... from sibling ?
        is there really case where it is needed ?
            e.g. pcsc keep a list of mapping reader name<=>relative addon
                the goal of this is to automaticaly select the correct reader addon in case of data transferring

        SOLUTION 1: save every information about add/remove/dup/... and manage it during unloading
            after trying to implement it, no simple and efficient way to do it...

            why is it a problem?
                -env or cont return a list of value, a python type list
                    two possibility, 
                        the list can be rebuilt each time an addon is loaded or unloaded and has an impact on this var
                        or the list canr be rebuilt each time a process call getValues and if load/unload had had on this var
                        no way to do it in another way because it is not possible to colorate list item in python...

                -in context, if an item is inserted twice, it can not be deleted if one of the addon is unloaded

            idea (to brainstorm?) can modify only transient variables
                so the update from an addon does not impact on next reboot
                but what about an addon unloading during execution ?

        SOLUTION 2: the original state is saved in the addons py file, save the current state at program exit
            on addon unload, do not remove anything

    
MODEL 5 (WEAK_ISOLATION(any)) (inherit properties from model 4) (CURRENT MODEL)
    
    any addon can update any elements of any addon, could produce a wonderful mess...






